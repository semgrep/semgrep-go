(* Generated by ocaml-tree-sitter. *)
(*
   go grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type int_literal = Token.t

type float_literal = Token.t

type imm_tok_dquot = Token.t (* "\"" *)

type rune_literal = Token.t

type escape_sequence = Token.t

type identifier = Token.t

type interpreted_string_literal_basic_content =
  Token.t (* pattern "[^\"\\n\\\\]+" *)

type semgrep_ellipsis_metavar =
  Token.t (* pattern \$\.\.\.[a-zA-Z_][a-zA-Z_0-9]* *)

type pat_1d78758 = Token.t (* pattern \n *)

type anon_choice_EQ_4ccabd6 = [
    `EQ of Token.t (* "=" *)
  | `COLONEQ of Token.t (* ":=" *)
]

type raw_string_literal = Token.t

type anon_choice_new_0342769 = [
    `New of Token.t (* "new" *)
  | `Make of Token.t (* "make" *)
]

type imaginary_literal = Token.t

type anon_choice_pat_1d78758_89f618f = [
    `Pat_1d78758 of pat_1d78758
  | `SEMI of Token.t (* ";" *)
  | `NUL of Token.t (* "\000" *)
]

type goto_statement = (Token.t (* "goto" *) * identifier (*tok*))

type field_name_list = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
)

type empty_labeled_statement = (identifier (*tok*) * Token.t (* ":" *))

type qualified_type = (
    identifier (*tok*) * Token.t (* "." *) * identifier (*tok*)
)

type break_statement = (Token.t (* "break" *) * identifier (*tok*) option)

type continue_statement = (
    Token.t (* "continue" *)
  * identifier (*tok*) option
)

type string_literal = [
    `Raw_str_lit of raw_string_literal (*tok*)
  | `Inte_str_lit of (
        Token.t (* "\"" *)
      * [
            `Inte_str_lit_basic_content of
              interpreted_string_literal_basic_content (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * imm_tok_dquot (*tok*)
    )
]

type anon_choice_exp_stmt_047b57a = [
    `Exp of expression_statement
  | `Vari_arg of (expression_statement * Token.t (* "..." *))
]

and anon_choice_lit_elem_0952f3f = [
    `Lit_elem of literal_element
  | `Keyed_elem of (literal_element * Token.t (* ":" *) * literal_element)
]

and anon_choice_param_decl_18823e5 = [
    `Param_decl of parameter_declaration
  | `Vari_param_decl of (
        identifier (*tok*) option
      * Token.t (* "..." *)
      * type_
    )
]

and anon_choice_param_list_29faba4 = [
    `Param_list of parameter_list
  | `Simple_type of simple_type
]

and argument_list = (
    Token.t (* "(" *)
  * (
        anon_choice_exp_stmt_047b57a
      * (Token.t (* "," *) * anon_choice_exp_stmt_047b57a)
          list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and array_type = (
    Token.t (* "[" *) * expression_statement * Token.t (* "]" *) * type_
)

and binary_expression = [
    `Exp_choice_STAR_exp of (
        expression_statement
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
          | `LTLT of Token.t (* "<<" *)
          | `GTGT of Token.t (* ">>" *)
          | `AMP of Token.t (* "&" *)
          | `AMPHAT of Token.t (* "&^" *)
        ]
      * expression_statement
    )
  | `Exp_choice_PLUS_exp of (
        expression_statement
      * [
            `PLUS of Token.t (* "+" *)
          | `DASH of Token.t (* "-" *)
          | `BAR of Token.t (* "|" *)
          | `HAT of Token.t (* "^" *)
        ]
      * expression_statement
    )
  | `Exp_choice_EQEQ_exp of (
        expression_statement
      * [
            `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
          | `GT of Token.t (* ">" *)
          | `GTEQ of Token.t (* ">=" *)
        ]
      * expression_statement
    )
  | `Exp_AMPAMP_exp of (
        expression_statement * Token.t (* "&&" *) * expression_statement
    )
  | `Exp_BARBAR_exp of (
        expression_statement * Token.t (* "||" *) * expression_statement
    )
]

and block = (Token.t (* "{" *) * statement_list option * Token.t (* "}" *))

and call_expression = [
    `Choice_new_spec_arg_list of (
        anon_choice_new_0342769 * special_argument_list
    )
  | `Exp_opt_type_args_arg_list of (
        expression_statement
      * type_arguments option
      * argument_list
    )
]

and channel_type = [
    `Chan_choice_simple_type of (Token.t (* "chan" *) * type_)
  | `Chan_LTDASH_choice_simple_type of (
        Token.t (* "chan" *) * Token.t (* "<-" *) * type_
    )
  | `LTDASH_chan_choice_simple_type of (
        Token.t (* "<-" *) * Token.t (* "chan" *) * type_
    )
]

and communication_case = (
    Token.t (* "case" *)
  * [ `Send_stmt of send_statement | `Rece_stmt of receive_statement ]
  * Token.t (* ":" *)
  * statement_list option
)

and composite_literal = (
    [
        `Map_type of map_type
      | `Slice_type of slice_type
      | `Array_type of array_type
      | `Impl_len_array_type of implicit_length_array_type
      | `Struct_type of struct_type
      | `Id of identifier (*tok*)
      | `Gene_type of generic_type
      | `Qual_type of qualified_type
    ]
  * literal_value
)

and const_spec = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * (type_ option * Token.t (* "=" *) * expression_list) option
)

and declaration = [
    `Const_decl of (
        Token.t (* "const" *)
      * [
            `Const_spec of const_spec
          | `LPAR_rep_const_spec_choice_pat_1d78758_RPAR of (
                Token.t (* "(" *)
              * (const_spec * anon_choice_pat_1d78758_89f618f)
                  list (* zero or more *)
              * Token.t (* ")" *)
            )
        ]
    )
  | `Type_decl of (
        Token.t (* "type" *)
      * [
            `Type_spec of type_spec
          | `Type_alias of type_alias
          | `LPAR_rep_choice_type_spec_choice_pat_1d78758_RPAR of (
                Token.t (* "(" *)
              * (
                    [ `Type_spec of type_spec | `Type_alias of type_alias ]
                  * anon_choice_pat_1d78758_89f618f
                )
                  list (* zero or more *)
              * Token.t (* ")" *)
            )
        ]
    )
  | `Var_decl of (
        Token.t (* "var" *)
      * [ `Var_spec of var_spec | `Var_spec_list of var_spec_list ]
    )
]

and default_case = (
    Token.t (* "default" *)
  * Token.t (* ":" *)
  * statement_list option
)

and defer_statement = (Token.t (* "defer" *) * expression_statement)

and expression = [
    `Choice_un_exp of [
        `Un_exp of unary_expression
      | `Bin_exp of binary_expression
      | `Sele_exp of selector_expression
      | `Index_exp of index_expression
      | `Slice_exp of slice_expression
      | `Call_exp of call_expression
      | `Type_asse_exp of type_assertion_expression
      | `Type_conv_exp of type_conversion_expression
      | `Type_inst_exp of type_instantiation_expression
      | `Id of identifier (*tok*)
      | `Choice_new of anon_choice_new_0342769
      | `Comp_lit of composite_literal
      | `Func_lit of func_literal
      | `Choice_raw_str_lit of string_literal
      | `Int_lit of int_literal (*tok*)
      | `Float_lit of float_literal (*tok*)
      | `Imag_lit of imaginary_literal (*tok*)
      | `Rune_lit of rune_literal (*tok*)
      | `Nil of Token.t (* "nil" *)
      | `True of Token.t (* "true" *)
      | `False of Token.t (* "false" *)
      | `Iota of Token.t (* "iota" *)
      | `Paren_exp of parenthesized_expression
    ]
  | `Semg_ellips_meta of semgrep_ellipsis_metavar (*tok*)
  | `Semg_deep_ellips of semgrep_deep_ellipsis
  | `Semg_ellips of Token.t (* "..." *)
  | `Typed_meta of (
        Token.t (* "(" *) * identifier (*tok*) * Token.t (* ":" *) * type_
      * Token.t (* ")" *)
    )
]

and expression_case = (
    Token.t (* "case" *)
  * expression_list
  * Token.t (* ":" *)
  * statement_list option
)

and expression_list = (
    expression_statement
  * (Token.t (* "," *) * expression_statement) list (* zero or more *)
)

and expression_statement = expression

and expression_switch_statement = (
    Token.t (* "switch" *)
  * (simple_statement * Token.t (* ";" *)) option
  * expression_statement option
  * Token.t (* "{" *)
  * [ `Exp_case of expression_case | `Defa_case of default_case ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and field_declaration = (
    [
        `Id_rep_COMMA_id_choice_simple_type of (
            identifier (*tok*)
          * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
          * type_
        )
      | `Opt_STAR_choice_id of (
            Token.t (* "*" *) option
          * [
                `Id of identifier (*tok*)
              | `Qual_type of qualified_type
              | `Gene_type of generic_type
            ]
        )
    ]
  * string_literal option
)

and field_declaration_list = (
    Token.t (* "{" *)
  * (
        field_declaration
      * (anon_choice_pat_1d78758_89f618f * field_declaration)
          list (* zero or more *)
      * anon_choice_pat_1d78758_89f618f option
    )
      option
  * Token.t (* "}" *)
)

and for_clause = (
    simple_statement option
  * Token.t (* ";" *)
  * expression_statement option
  * Token.t (* ";" *)
  * simple_statement option
)

and for_statement = (
    Token.t (* "for" *)
  * [
        `Exp of expression_statement
      | `For_clause of for_clause
      | `Range_clause of range_clause
    ]
      option
  * block
)

and func_literal = (
    Token.t (* "func" *)
  * parameter_list
  * anon_choice_param_list_29faba4 option
  * block
)

and generic_type = (
    [
        `Id of identifier (*tok*)
      | `Qual_type of qualified_type
      | `Nega_type of negated_type
    ]
  * type_arguments
)

and go_statement = (Token.t (* "go" *) * expression_statement)

and if_statement = (
    Token.t (* "if" *)
  * (simple_statement * Token.t (* ";" *)) option
  * expression_statement
  * block
  * (Token.t (* "else" *) * [ `Blk of block | `If_stmt of if_statement ])
      option
)

and implicit_length_array_type = (
    Token.t (* "[" *) * Token.t (* "..." *) * Token.t (* "]" *) * type_
)

and index_expression = (
    expression_statement * Token.t (* "[" *) * expression_statement
  * Token.t (* "]" *)
)

and interface_elem = [
    `Meth_elem of (
        identifier (*tok*)
      * parameter_list
      * anon_choice_param_list_29faba4 option
    )
  | `Type_elem of type_elem
]

and labeled_statement = (identifier (*tok*) * Token.t (* ":" *) * statement)

and literal_element = [
    `Exp of expression_statement
  | `Lit_value of literal_value
]

and literal_value = (
    Token.t (* "{" *)
  * (
        (
            anon_choice_lit_elem_0952f3f
          * (Token.t (* "," *) * anon_choice_lit_elem_0952f3f)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "}" *)
)

and map_type = (
    Token.t (* "map" *) * Token.t (* "[" *) * type_ * Token.t (* "]" *)
  * type_
)

and negated_type = (Token.t (* "~" *) * type_)

and parameter_declaration = [
    `Semg_ellips of Token.t (* "..." *)
  | `Semg_ellips_meta of semgrep_ellipsis_metavar (*tok*)
  | `Opt_id_rep_COMMA_id_choice_simple_type of (
        field_name_list option
      * type_
    )
]

and parameter_list = (
    Token.t (* "(" *)
  * (
        (
            anon_choice_param_decl_18823e5
          * (Token.t (* "," *) * anon_choice_param_decl_18823e5)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and parenthesized_expression = (
    Token.t (* "(" *) * expression_statement * Token.t (* ")" *)
)

and range_clause = (
    (expression_list * anon_choice_EQ_4ccabd6) option
  * Token.t (* "range" *)
  * expression_statement
)

and receive_statement = (
    (expression_list * anon_choice_EQ_4ccabd6) option
  * expression_statement
)

and return_statement = (Token.t (* "return" *) * expression_list option)

and select_statement = (
    Token.t (* "select" *)
  * Token.t (* "{" *)
  * [ `Comm_case of communication_case | `Defa_case of default_case ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and selector_expression = (
    expression_statement * Token.t (* "." *) * identifier (*tok*)
)

and semgrep_deep_ellipsis = (
    Token.t (* "<..." *) * expression_statement * Token.t (* "...>" *)
)

and send_statement = (
    expression_statement * Token.t (* "<-" *) * expression_statement
)

and simple_statement = [
    `Exp_stmt of expression_statement
  | `Send_stmt of send_statement
  | `Inc_stmt of (expression_statement * Token.t (* "++" *))
  | `Dec_stmt of (expression_statement * Token.t (* "--" *))
  | `Assign_stmt of (
        expression_list
      * [
            `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `AMPHATEQ of Token.t (* "&^=" *)
          | `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `EQ of Token.t (* "=" *)
        ]
      * expression_list
    )
  | `Short_var_decl of (
        expression_list * Token.t (* ":=" *) * expression_list
    )
]

and simple_type = [
    `Id of identifier (*tok*)
  | `Gene_type of generic_type
  | `Qual_type of qualified_type
  | `Poin_type of (Token.t (* "*" *) * type_)
  | `Struct_type of struct_type
  | `Inte_type of (
        Token.t (* "interface" *)
      * Token.t (* "{" *)
      * (
            interface_elem
          * (anon_choice_pat_1d78758_89f618f * interface_elem)
              list (* zero or more *)
          * anon_choice_pat_1d78758_89f618f option
        )
          option
      * Token.t (* "}" *)
    )
  | `Array_type of array_type
  | `Slice_type of slice_type
  | `Map_type of map_type
  | `Chan_type of channel_type
  | `Func_type of (
        Token.t (* "func" *)
      * parameter_list
      * anon_choice_param_list_29faba4 option
    )
  | `Nega_type of negated_type
]

and slice_expression = (
    expression_statement
  * Token.t (* "[" *)
  * [
        `Opt_exp_COLON_opt_exp of (
            expression_statement option
          * Token.t (* ":" *)
          * expression_statement option
        )
      | `Opt_exp_COLON_exp_COLON_exp of (
            expression_statement option
          * Token.t (* ":" *)
          * expression_statement
          * Token.t (* ":" *)
          * expression_statement
        )
    ]
  * Token.t (* "]" *)
)

and slice_type = (Token.t (* "[" *) * Token.t (* "]" *) * type_)

and special_argument_list = (
    Token.t (* "(" *)
  * (
        type_
      * (Token.t (* "," *) * expression_statement) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and statement = [
    `Choice_decl of [
        `Decl of declaration
      | `Simple_stmt of simple_statement
      | `Ret_stmt of return_statement
      | `Go_stmt of go_statement
      | `Defer_stmt of defer_statement
      | `If_stmt of if_statement
      | `For_stmt of for_statement
      | `Exp_switch_stmt of expression_switch_statement
      | `Type_switch_stmt of type_switch_statement
      | `Select_stmt of select_statement
      | `Labe_stmt of labeled_statement
      | `Fall_stmt of Token.t (* "fallthrough" *)
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Goto_stmt of goto_statement
      | `Blk of block
      | `Empty_stmt of Token.t (* ";" *)
    ]
  | `Semg_ellips_meta of semgrep_ellipsis_metavar (*tok*)
  | `Semg_deep_ellips of semgrep_deep_ellipsis
  | `Semg_ellips of Token.t (* "..." *)
]

and statement_list = [
    `Stmt_rep_choice_pat_1d78758_stmt_opt_choice_pat_1d78758_opt_empty_labe_stmt of (
        statement
      * (anon_choice_pat_1d78758_89f618f * statement) list (* zero or more *)
      * (anon_choice_pat_1d78758_89f618f * empty_labeled_statement option)
          option
    )
  | `Empty_labe_stmt of empty_labeled_statement
]

and struct_type = (Token.t (* "struct" *) * field_declaration_list)

and type_ = [
    `Simple_type of simple_type
  | `Paren_type of (Token.t (* "(" *) * type_ * Token.t (* ")" *))
]

and type_alias = (identifier (*tok*) * Token.t (* "=" *) * type_)

and type_arguments = (
    Token.t (* "[" *)
  * type_elem
  * (Token.t (* "," *) * type_elem) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and type_assertion_expression = (
    expression_statement * Token.t (* "." *) * Token.t (* "(" *) * type_
  * Token.t (* ")" *)
)

and type_case = (
    Token.t (* "case" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* ":" *)
  * statement_list option
)

and type_conversion_expression = (
    type_
  * Token.t (* "(" *)
  * expression_statement
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and type_elem = (type_ * (Token.t (* "|" *) * type_) list (* zero or more *))

and type_instantiation_expression = (
    type_
  * Token.t (* "[" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and type_parameter_declaration = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * type_elem
)

and type_parameter_list = (
    Token.t (* "[" *)
  * type_parameter_declaration
  * (Token.t (* "," *) * type_parameter_declaration) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and type_spec = (identifier (*tok*) * type_parameter_list option * type_)

and type_switch_header = (
    (simple_statement * Token.t (* ";" *)) option
  * (expression_list * Token.t (* ":=" *)) option
  * expression_statement
  * Token.t (* "." *)
  * Token.t (* "(" *)
  * Token.t (* "type" *)
  * Token.t (* ")" *)
)

and type_switch_statement = (
    Token.t (* "switch" *)
  * type_switch_header
  * Token.t (* "{" *)
  * [ `Type_case of type_case | `Defa_case of default_case ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and unary_expression = (
    [
        `PLUS of Token.t (* "+" *)
      | `DASH of Token.t (* "-" *)
      | `BANG of Token.t (* "!" *)
      | `HAT of Token.t (* "^" *)
      | `STAR of Token.t (* "*" *)
      | `AMP of Token.t (* "&" *)
      | `LTDASH of Token.t (* "<-" *)
    ]
  * expression_statement
)

and var_spec = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * [
        `Choice_simple_type_opt_EQ_exp_list of (
            type_
          * (Token.t (* "=" *) * expression_list) option
        )
      | `EQ_exp_list of (Token.t (* "=" *) * expression_list)
    ]
)

and var_spec_list = (
    Token.t (* "(" *)
  * (var_spec * anon_choice_pat_1d78758_89f618f) list (* zero or more *)
  * Token.t (* ")" *)
)

type import_spec = (
    [
        `Dot of Token.t (* "." *)
      | `Blank_id of Token.t (* "_" *)
      | `Id of identifier (*tok*)
    ]
      option
  * string_literal
)

type import_spec_list = (
    Token.t (* "(" *)
  * (
        import_spec
      * (anon_choice_pat_1d78758_89f618f * import_spec)
          list (* zero or more *)
      * anon_choice_pat_1d78758_89f618f option
    )
      option
  * Token.t (* ")" *)
)

type top_level_declaration = [
    `Pack_clause of (Token.t (* "package" *) * identifier (*tok*))
  | `Func_decl of (
        Token.t (* "func" *)
      * identifier (*tok*)
      * type_parameter_list option
      * parameter_list
      * anon_choice_param_list_29faba4 option
      * block option
    )
  | `Meth_decl of (
        Token.t (* "func" *)
      * parameter_list
      * identifier (*tok*)
      * parameter_list
      * anon_choice_param_list_29faba4 option
      * block option
    )
  | `Import_decl of (
        Token.t (* "import" *)
      * [
            `Import_spec of import_spec
          | `Import_spec_list of import_spec_list
        ]
    )
]

type source_file = (
    [
        `Stmt_choice_pat_1d78758 of (
            statement * anon_choice_pat_1d78758_89f618f
        )
      | `Choice_pack_clause_choice_pat_1d78758 of (
            top_level_declaration * anon_choice_pat_1d78758_89f618f
        )
    ]
      list (* zero or more *)
  * top_level_declaration option
)

type blank_identifier (* inlined *) = Token.t (* "_" *)

type nil (* inlined *) = Token.t (* "nil" *)

type fallthrough_statement (* inlined *) = Token.t (* "fallthrough" *)

type dot (* inlined *) = Token.t (* "." *)

type false_ (* inlined *) = Token.t (* "false" *)

type comment (* inlined *) = Token.t

type iota (* inlined *) = Token.t (* "iota" *)

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type empty_statement (* inlined *) = Token.t (* ";" *)

type true_ (* inlined *) = Token.t (* "true" *)

type field_identifier (* inlined *) = identifier (*tok*)

type package_identifier (* inlined *) = identifier (*tok*)

type type_identifier (* inlined *) = identifier (*tok*)

type interpreted_string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [
        `Inte_str_lit_basic_content of
          interpreted_string_literal_basic_content (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * imm_tok_dquot (*tok*)
)

type package_clause (* inlined *) = (
    Token.t (* "package" *) * identifier (*tok*)
)

type assignment_statement (* inlined *) = (
    expression_list
  * [
        `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `AMPHATEQ of Token.t (* "&^=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `EQ of Token.t (* "=" *)
    ]
  * expression_list
)

type const_declaration (* inlined *) = (
    Token.t (* "const" *)
  * [
        `Const_spec of const_spec
      | `LPAR_rep_const_spec_choice_pat_1d78758_RPAR of (
            Token.t (* "(" *)
          * (const_spec * anon_choice_pat_1d78758_89f618f)
              list (* zero or more *)
          * Token.t (* ")" *)
        )
    ]
)

type dec_statement (* inlined *) = (
    expression_statement * Token.t (* "--" *)
)

type function_type (* inlined *) = (
    Token.t (* "func" *)
  * parameter_list
  * anon_choice_param_list_29faba4 option
)

type inc_statement (* inlined *) = (
    expression_statement * Token.t (* "++" *)
)

type interface_type (* inlined *) = (
    Token.t (* "interface" *)
  * Token.t (* "{" *)
  * (
        interface_elem
      * (anon_choice_pat_1d78758_89f618f * interface_elem)
          list (* zero or more *)
      * anon_choice_pat_1d78758_89f618f option
    )
      option
  * Token.t (* "}" *)
)

type keyed_element (* inlined *) = (
    literal_element * Token.t (* ":" *) * literal_element
)

type method_elem (* inlined *) = (
    identifier (*tok*)
  * parameter_list
  * anon_choice_param_list_29faba4 option
)

type parenthesized_type (* inlined *) = (
    Token.t (* "(" *) * type_ * Token.t (* ")" *)
)

type pointer_type (* inlined *) = (Token.t (* "*" *) * type_)

type short_var_declaration (* inlined *) = (
    expression_list * Token.t (* ":=" *) * expression_list
)

type type_declaration (* inlined *) = (
    Token.t (* "type" *)
  * [
        `Type_spec of type_spec
      | `Type_alias of type_alias
      | `LPAR_rep_choice_type_spec_choice_pat_1d78758_RPAR of (
            Token.t (* "(" *)
          * (
                [ `Type_spec of type_spec | `Type_alias of type_alias ]
              * anon_choice_pat_1d78758_89f618f
            )
              list (* zero or more *)
          * Token.t (* ")" *)
        )
    ]
)

type typed_metavar (* inlined *) = (
    Token.t (* "(" *) * identifier (*tok*) * Token.t (* ":" *) * type_
  * Token.t (* ")" *)
)

type var_declaration (* inlined *) = (
    Token.t (* "var" *)
  * [ `Var_spec of var_spec | `Var_spec_list of var_spec_list ]
)

type variadic_argument (* inlined *) = (
    expression_statement * Token.t (* "..." *)
)

type variadic_parameter_declaration (* inlined *) = (
    identifier (*tok*) option
  * Token.t (* "..." *)
  * type_
)

type function_declaration (* inlined *) = (
    Token.t (* "func" *)
  * identifier (*tok*)
  * type_parameter_list option
  * parameter_list
  * anon_choice_param_list_29faba4 option
  * block option
)

type method_declaration (* inlined *) = (
    Token.t (* "func" *)
  * parameter_list
  * identifier (*tok*)
  * parameter_list
  * anon_choice_param_list_29faba4 option
  * block option
)

type import_declaration (* inlined *) = (
    Token.t (* "import" *)
  * [ `Import_spec of import_spec | `Import_spec_list of import_spec_list ]
)

type extra = Comment of Loc.t * comment

type extras = extra list
