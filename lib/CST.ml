(* Generated by ocaml-tree-sitter. *)
(*
   go grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type float_literal = Token.t

type anon_choice_LF_249c99f = [
    `LF of Token.t (* "\n" *)
  | `SEMI of Token.t (* ";" *)
]

type anon_choice_new_0342769 = [
    `New of Token.t (* "new" *)
  | `Make of Token.t (* "make" *)
]

type identifier = Token.t

type raw_string_literal = Token.t

type int_literal = Token.t

type escape_sequence = Token.t

type imaginary_literal = Token.t

type rune_literal = Token.t

type anon_choice_EQ_4ccabd6 = [
    `EQ of Token.t (* "=" *)
  | `COLONEQ of Token.t (* ":=" *)
]

type interpreted_string_literal_basic_content =
  Token.t (* pattern "[^\"\\n\\\\]+" *)

type constraint_term = (Token.t (* "~" *) option * identifier (*tok*))

type empty_labeled_statement = (identifier (*tok*) * Token.t (* ":" *))

type field_name_list = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
)

type qualified_type = (
    identifier (*tok*) * Token.t (* "." *) * identifier (*tok*)
)

type string_literal = [
    `Raw_str_lit of raw_string_literal (*tok*)
  | `Inte_str_lit of (
        Token.t (* "\"" *)
      * [
            `Inte_str_lit_basic_content of
              interpreted_string_literal_basic_content (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
]

type interface_type_name = [
    `Id of identifier (*tok*)
  | `Qual_type of qualified_type
]

type import_spec = (
    [
        `Dot of Token.t (* "." *)
      | `Blank_id of Token.t (* "_" *)
      | `Id of identifier (*tok*)
    ]
      option
  * string_literal
)

type anon_choice_exp_047b57a = [
    `Exp of expression
  | `Vari_arg of (expression * Token.t (* "..." *))
]

and anon_choice_lit_elem_0952f3f = [
    `Lit_elem of literal_element
  | `Keyed_elem of (literal_element * Token.t (* ":" *) * literal_element)
]

and anon_choice_param_decl_18823e5 = [
    `Param_decl of parameter_declaration
  | `Vari_param_decl of (
        identifier (*tok*) option
      * Token.t (* "..." *)
      * type_
    )
]

and anon_choice_param_list_29faba4 = [
    `Param_list of parameter_list
  | `Simple_type of simple_type
]

and argument_list = (
    Token.t (* "(" *)
  * (
        anon_choice_exp_047b57a
      * (Token.t (* "," *) * anon_choice_exp_047b57a) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and array_type = (Token.t (* "[" *) * expression * Token.t (* "]" *) * type_)

and binary_expression = [
    `Exp_choice_STAR_exp of (
        expression
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
          | `LTLT of Token.t (* "<<" *)
          | `GTGT of Token.t (* ">>" *)
          | `AMP of Token.t (* "&" *)
          | `AMPHAT of Token.t (* "&^" *)
        ]
      * expression
    )
  | `Exp_choice_PLUS_exp of (
        expression
      * [
            `PLUS of Token.t (* "+" *)
          | `DASH of Token.t (* "-" *)
          | `BAR of Token.t (* "|" *)
          | `HAT of Token.t (* "^" *)
        ]
      * expression
    )
  | `Exp_choice_EQEQ_exp of (
        expression
      * [
            `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
          | `GT of Token.t (* ">" *)
          | `GTEQ of Token.t (* ">=" *)
        ]
      * expression
    )
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
]

and block = (Token.t (* "{" *) * statement_list option * Token.t (* "}" *))

and call_expression = [
    `Choice_new_spec_arg_list of (
        anon_choice_new_0342769 * special_argument_list
    )
  | `Exp_opt_type_args_arg_list of (
        expression
      * type_arguments option
      * argument_list
    )
]

and channel_type = [
    `Chan_choice_simple_type of (Token.t (* "chan" *) * type_)
  | `Chan_LTDASH_choice_simple_type of (
        Token.t (* "chan" *) * Token.t (* "<-" *) * type_
    )
  | `LTDASH_chan_choice_simple_type of (
        Token.t (* "<-" *) * Token.t (* "chan" *) * type_
    )
]

and communication_case = (
    Token.t (* "case" *)
  * [ `Send_stmt of send_statement | `Rece_stmt of receive_statement ]
  * Token.t (* ":" *)
  * statement_list option
)

and const_spec = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * (type_ option * Token.t (* "=" *) * expression_list) option
)

and declaration = [
    `Const_decl of (
        Token.t (* "const" *)
      * [
            `Const_spec of const_spec
          | `LPAR_rep_const_spec_choice_LF_RPAR of (
                Token.t (* "(" *)
              * (const_spec * anon_choice_LF_249c99f) list (* zero or more *)
              * Token.t (* ")" *)
            )
        ]
    )
  | `Type_decl of (
        Token.t (* "type" *)
      * [
            `Type_spec of type_spec
          | `Type_alias of type_alias
          | `LPAR_rep_choice_type_spec_choice_LF_RPAR of (
                Token.t (* "(" *)
              * (
                    [ `Type_spec of type_spec | `Type_alias of type_alias ]
                  * anon_choice_LF_249c99f
                )
                  list (* zero or more *)
              * Token.t (* ")" *)
            )
        ]
    )
  | `Var_decl of (
        Token.t (* "var" *)
      * [
            `Var_spec of var_spec
          | `LPAR_rep_var_spec_choice_LF_RPAR of (
                Token.t (* "(" *)
              * (var_spec * anon_choice_LF_249c99f) list (* zero or more *)
              * Token.t (* ")" *)
            )
        ]
    )
]

and default_case = (
    Token.t (* "default" *)
  * Token.t (* ":" *)
  * statement_list option
)

and expression = [
    `Un_exp of (
        [
            `PLUS of Token.t (* "+" *)
          | `DASH of Token.t (* "-" *)
          | `BANG of Token.t (* "!" *)
          | `HAT of Token.t (* "^" *)
          | `STAR of Token.t (* "*" *)
          | `AMP of Token.t (* "&" *)
          | `LTDASH of Token.t (* "<-" *)
        ]
      * expression
    )
  | `Bin_exp of binary_expression
  | `Sele_exp of (expression * Token.t (* "." *) * identifier (*tok*))
  | `Index_exp of (
        expression * Token.t (* "[" *) * expression * Token.t (* "]" *)
    )
  | `Slice_exp of (
        expression
      * Token.t (* "[" *)
      * [
            `Opt_exp_COLON_opt_exp of (
                expression option
              * Token.t (* ":" *)
              * expression option
            )
          | `Opt_exp_COLON_exp_COLON_exp of (
                expression option
              * Token.t (* ":" *)
              * expression
              * Token.t (* ":" *)
              * expression
            )
        ]
      * Token.t (* "]" *)
    )
  | `Call_exp of call_expression
  | `Type_asse_exp of (
        expression * Token.t (* "." *) * Token.t (* "(" *) * type_
      * Token.t (* ")" *)
    )
  | `Type_conv_exp of (
        type_
      * Token.t (* "(" *)
      * expression
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
  | `Id of identifier (*tok*)
  | `Choice_new of anon_choice_new_0342769
  | `Comp_lit of (
        [
            `Map_type of map_type
          | `Slice_type of slice_type
          | `Array_type of array_type
          | `Impl_len_array_type of implicit_length_array_type
          | `Struct_type of struct_type
          | `Id of identifier (*tok*)
          | `Gene_type of generic_type
          | `Qual_type of qualified_type
        ]
      * literal_value
    )
  | `Func_lit of (
        Token.t (* "func" *)
      * parameter_list
      * anon_choice_param_list_29faba4 option
      * block
    )
  | `Choice_raw_str_lit of string_literal
  | `Int_lit of int_literal (*tok*)
  | `Float_lit of float_literal (*tok*)
  | `Imag_lit of imaginary_literal (*tok*)
  | `Rune_lit of rune_literal (*tok*)
  | `Nil of Token.t (* "nil" *)
  | `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
  | `Iota of Token.t (* "iota" *)
  | `Paren_exp of (Token.t (* "(" *) * expression * Token.t (* ")" *))
]

and expression_case = (
    Token.t (* "case" *)
  * expression_list
  * Token.t (* ":" *)
  * statement_list option
)

and expression_list = (
    expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
)

and field_declaration = (
    [
        `Id_rep_COMMA_id_choice_simple_type of (
            identifier (*tok*)
          * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
          * type_
        )
      | `Opt_STAR_choice_id of (
            Token.t (* "*" *) option
          * interface_type_name
        )
    ]
  * string_literal option
)

and field_declaration_list = (
    Token.t (* "{" *)
  * (
        field_declaration
      * (anon_choice_LF_249c99f * field_declaration) list (* zero or more *)
      * anon_choice_LF_249c99f option
    )
      option
  * Token.t (* "}" *)
)

and for_clause = (
    simple_statement option
  * Token.t (* ";" *)
  * expression option
  * Token.t (* ";" *)
  * simple_statement option
)

and generic_type = (interface_type_name * type_arguments)

and if_statement = (
    Token.t (* "if" *)
  * (simple_statement * Token.t (* ";" *)) option
  * expression
  * block
  * (Token.t (* "else" *) * [ `Blk of block | `If_stmt of if_statement ])
      option
)

and implicit_length_array_type = (
    Token.t (* "[" *) * Token.t (* "..." *) * Token.t (* "]" *) * type_
)

and interface_body = [
    `Meth_spec of (
        identifier (*tok*)
      * parameter_list
      * anon_choice_param_list_29faba4 option
    )
  | `Inte_type_name of interface_type_name
  | `Cons_elem of (
        constraint_term
      * (Token.t (* "|" *) * constraint_term) list (* zero or more *)
    )
  | `Struct_elem of (
        struct_term
      * (Token.t (* "|" *) * struct_term) list (* zero or more *)
    )
]

and literal_element = [ `Exp of expression | `Lit_value of literal_value ]

and literal_value = (
    Token.t (* "{" *)
  * (
        (
            anon_choice_lit_elem_0952f3f
          * (Token.t (* "," *) * anon_choice_lit_elem_0952f3f)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "}" *)
)

and map_type = (
    Token.t (* "map" *) * Token.t (* "[" *) * type_ * Token.t (* "]" *)
  * type_
)

and parameter_declaration = (field_name_list option * type_)

and parameter_list = (
    Token.t (* "(" *)
  * (
        (
            anon_choice_param_decl_18823e5
          * (Token.t (* "," *) * anon_choice_param_decl_18823e5)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and range_clause = (
    (expression_list * anon_choice_EQ_4ccabd6) option
  * Token.t (* "range" *)
  * expression
)

and receive_statement = (
    (expression_list * anon_choice_EQ_4ccabd6) option
  * expression
)

and send_statement = (expression * Token.t (* "<-" *) * expression)

and simple_statement = [
    `Exp of expression
  | `Send_stmt of send_statement
  | `Inc_stmt of (expression * Token.t (* "++" *))
  | `Dec_stmt of (expression * Token.t (* "--" *))
  | `Assign_stmt of (
        expression_list
      * [
            `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `AMPHATEQ of Token.t (* "&^=" *)
          | `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `EQ of Token.t (* "=" *)
        ]
      * expression_list
    )
  | `Short_var_decl of (
        expression_list * Token.t (* ":=" *) * expression_list
    )
]

and simple_type = [
    `Id of identifier (*tok*)
  | `Gene_type of generic_type
  | `Qual_type of qualified_type
  | `Poin_type of (Token.t (* "*" *) * type_)
  | `Struct_type of struct_type
  | `Inte_type of (
        Token.t (* "interface" *)
      * Token.t (* "{" *)
      * (
            interface_body
          * (anon_choice_LF_249c99f * interface_body) list (* zero or more *)
          * anon_choice_LF_249c99f option
        )
          option
      * Token.t (* "}" *)
    )
  | `Array_type of array_type
  | `Slice_type of slice_type
  | `Map_type of map_type
  | `Chan_type of channel_type
  | `Func_type of (
        Token.t (* "func" *)
      * parameter_list
      * anon_choice_param_list_29faba4 option
    )
]

and slice_type = (Token.t (* "[" *) * Token.t (* "]" *) * type_)

and special_argument_list = (
    Token.t (* "(" *)
  * type_
  * (Token.t (* "," *) * expression) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and statement = [
    `Decl of declaration
  | `Simple_stmt of simple_statement
  | `Ret_stmt of (Token.t (* "return" *) * expression_list option)
  | `Go_stmt of (Token.t (* "go" *) * expression)
  | `Defer_stmt of (Token.t (* "defer" *) * expression)
  | `If_stmt of if_statement
  | `For_stmt of (
        Token.t (* "for" *)
      * [
            `Exp of expression
          | `For_clause of for_clause
          | `Range_clause of range_clause
        ]
          option
      * block
    )
  | `Exp_switch_stmt of (
        Token.t (* "switch" *)
      * (simple_statement * Token.t (* ";" *)) option
      * expression option
      * Token.t (* "{" *)
      * [ `Exp_case of expression_case | `Defa_case of default_case ]
          list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `Type_switch_stmt of (
        Token.t (* "switch" *)
      * type_switch_header
      * Token.t (* "{" *)
      * [ `Type_case of type_case | `Defa_case of default_case ]
          list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `Select_stmt of (
        Token.t (* "select" *)
      * Token.t (* "{" *)
      * [ `Comm_case of communication_case | `Defa_case of default_case ]
          list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `Labe_stmt of (identifier (*tok*) * Token.t (* ":" *) * statement)
  | `Fall_stmt of Token.t (* "fallthrough" *)
  | `Brk_stmt of (Token.t (* "break" *) * identifier (*tok*) option)
  | `Cont_stmt of (Token.t (* "continue" *) * identifier (*tok*) option)
  | `Goto_stmt of (Token.t (* "goto" *) * identifier (*tok*))
  | `Blk of block
  | `Empty_stmt of Token.t (* ";" *)
]

and statement_list = [
    `Stmt_rep_choice_LF_stmt_opt_choice_LF_opt_empty_labe_stmt of (
        statement
      * (anon_choice_LF_249c99f * statement) list (* zero or more *)
      * (anon_choice_LF_249c99f * empty_labeled_statement option) option
    )
  | `Empty_labe_stmt of empty_labeled_statement
]

and struct_term = (
    [ `TILDE of Token.t (* "~" *) | `STAR of Token.t (* "*" *) ] option
  * struct_type
)

and struct_type = (Token.t (* "struct" *) * field_declaration_list)

and type_ = [
    `Simple_type of simple_type
  | `Paren_type of (Token.t (* "(" *) * type_ * Token.t (* ")" *))
]

and type_alias = (identifier (*tok*) * Token.t (* "=" *) * type_)

and type_arguments = (
    Token.t (* "[" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and type_case = (
    Token.t (* "case" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* ":" *)
  * statement_list option
)

and type_parameter_list = (
    Token.t (* "[" *)
  * parameter_declaration
  * (Token.t (* "," *) * parameter_declaration) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and type_spec = (identifier (*tok*) * type_parameter_list option * type_)

and type_switch_header = (
    (simple_statement * Token.t (* ";" *)) option
  * (expression_list * Token.t (* ":=" *)) option
  * expression
  * Token.t (* "." *)
  * Token.t (* "(" *)
  * Token.t (* "type" *)
  * Token.t (* ")" *)
)

and var_spec = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * [
        `Choice_simple_type_opt_EQ_exp_list of (
            type_
          * (Token.t (* "=" *) * expression_list) option
        )
      | `EQ_exp_list of (Token.t (* "=" *) * expression_list)
    ]
)

type import_spec_list = (
    Token.t (* "(" *)
  * (import_spec * anon_choice_LF_249c99f) list (* zero or more *)
  * Token.t (* ")" *)
)

type top_level_declaration = [
    `Pack_clause of (Token.t (* "package" *) * identifier (*tok*))
  | `Func_decl of (
        Token.t (* "func" *)
      * identifier (*tok*)
      * type_parameter_list option
      * parameter_list
      * anon_choice_param_list_29faba4 option
      * block option
    )
  | `Meth_decl of (
        Token.t (* "func" *)
      * parameter_list
      * identifier (*tok*)
      * parameter_list
      * anon_choice_param_list_29faba4 option
      * block option
    )
  | `Import_decl of (
        Token.t (* "import" *)
      * [
            `Import_spec of import_spec
          | `Import_spec_list of import_spec_list
        ]
    )
]

type source_file =
  [
      `Stmt_choice_LF of (statement * anon_choice_LF_249c99f)
    | `Choice_pack_clause_opt_choice_LF of (
          top_level_declaration
        * anon_choice_LF_249c99f option
      )
  ]
    list (* zero or more *)

type blank_identifier (* inlined *) = Token.t (* "_" *)

type iota (* inlined *) = Token.t (* "iota" *)

type fallthrough_statement (* inlined *) = Token.t (* "fallthrough" *)

type false_ (* inlined *) = Token.t (* "false" *)

type empty_statement (* inlined *) = Token.t (* ";" *)

type nil (* inlined *) = Token.t (* "nil" *)

type comment (* inlined *) = Token.t

type true_ (* inlined *) = Token.t (* "true" *)

type dot (* inlined *) = Token.t (* "." *)

type field_identifier (* inlined *) = identifier (*tok*)

type package_identifier (* inlined *) = identifier (*tok*)

type type_identifier (* inlined *) = identifier (*tok*)

type interpreted_string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [
        `Inte_str_lit_basic_content of
          interpreted_string_literal_basic_content (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)

type continue_statement (* inlined *) = (
    Token.t (* "continue" *)
  * identifier (*tok*) option
)

type break_statement (* inlined *) = (
    Token.t (* "break" *)
  * identifier (*tok*) option
)

type package_clause (* inlined *) = (
    Token.t (* "package" *) * identifier (*tok*)
)

type goto_statement (* inlined *) = (
    Token.t (* "goto" *) * identifier (*tok*)
)

type constraint_elem (* inlined *) = (
    constraint_term
  * (Token.t (* "|" *) * constraint_term) list (* zero or more *)
)

type assignment_statement (* inlined *) = (
    expression_list
  * [
        `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `AMPHATEQ of Token.t (* "&^=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `EQ of Token.t (* "=" *)
    ]
  * expression_list
)

type composite_literal (* inlined *) = (
    [
        `Map_type of map_type
      | `Slice_type of slice_type
      | `Array_type of array_type
      | `Impl_len_array_type of implicit_length_array_type
      | `Struct_type of struct_type
      | `Id of identifier (*tok*)
      | `Gene_type of generic_type
      | `Qual_type of qualified_type
    ]
  * literal_value
)

type const_declaration (* inlined *) = (
    Token.t (* "const" *)
  * [
        `Const_spec of const_spec
      | `LPAR_rep_const_spec_choice_LF_RPAR of (
            Token.t (* "(" *)
          * (const_spec * anon_choice_LF_249c99f) list (* zero or more *)
          * Token.t (* ")" *)
        )
    ]
)

type dec_statement (* inlined *) = (expression * Token.t (* "--" *))

type defer_statement (* inlined *) = (Token.t (* "defer" *) * expression)

type expression_switch_statement (* inlined *) = (
    Token.t (* "switch" *)
  * (simple_statement * Token.t (* ";" *)) option
  * expression option
  * Token.t (* "{" *)
  * [ `Exp_case of expression_case | `Defa_case of default_case ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * [
        `Exp of expression
      | `For_clause of for_clause
      | `Range_clause of range_clause
    ]
      option
  * block
)

type func_literal (* inlined *) = (
    Token.t (* "func" *)
  * parameter_list
  * anon_choice_param_list_29faba4 option
  * block
)

type function_type (* inlined *) = (
    Token.t (* "func" *)
  * parameter_list
  * anon_choice_param_list_29faba4 option
)

type go_statement (* inlined *) = (Token.t (* "go" *) * expression)

type inc_statement (* inlined *) = (expression * Token.t (* "++" *))

type index_expression (* inlined *) = (
    expression * Token.t (* "[" *) * expression * Token.t (* "]" *)
)

type interface_type (* inlined *) = (
    Token.t (* "interface" *)
  * Token.t (* "{" *)
  * (
        interface_body
      * (anon_choice_LF_249c99f * interface_body) list (* zero or more *)
      * anon_choice_LF_249c99f option
    )
      option
  * Token.t (* "}" *)
)

type keyed_element (* inlined *) = (
    literal_element * Token.t (* ":" *) * literal_element
)

type labeled_statement (* inlined *) = (
    identifier (*tok*) * Token.t (* ":" *) * statement
)

type method_spec (* inlined *) = (
    identifier (*tok*)
  * parameter_list
  * anon_choice_param_list_29faba4 option
)

type parenthesized_expression (* inlined *) = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)

type parenthesized_type (* inlined *) = (
    Token.t (* "(" *) * type_ * Token.t (* ")" *)
)

type pointer_type (* inlined *) = (Token.t (* "*" *) * type_)

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * expression_list option
)

type select_statement (* inlined *) = (
    Token.t (* "select" *)
  * Token.t (* "{" *)
  * [ `Comm_case of communication_case | `Defa_case of default_case ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type selector_expression (* inlined *) = (
    expression * Token.t (* "." *) * identifier (*tok*)
)

type short_var_declaration (* inlined *) = (
    expression_list * Token.t (* ":=" *) * expression_list
)

type slice_expression (* inlined *) = (
    expression
  * Token.t (* "[" *)
  * [
        `Opt_exp_COLON_opt_exp of (
            expression option
          * Token.t (* ":" *)
          * expression option
        )
      | `Opt_exp_COLON_exp_COLON_exp of (
            expression option
          * Token.t (* ":" *)
          * expression
          * Token.t (* ":" *)
          * expression
        )
    ]
  * Token.t (* "]" *)
)

type struct_elem (* inlined *) = (
    struct_term
  * (Token.t (* "|" *) * struct_term) list (* zero or more *)
)

type type_assertion_expression (* inlined *) = (
    expression * Token.t (* "." *) * Token.t (* "(" *) * type_
  * Token.t (* ")" *)
)

type type_conversion_expression (* inlined *) = (
    type_
  * Token.t (* "(" *)
  * expression
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

type type_declaration (* inlined *) = (
    Token.t (* "type" *)
  * [
        `Type_spec of type_spec
      | `Type_alias of type_alias
      | `LPAR_rep_choice_type_spec_choice_LF_RPAR of (
            Token.t (* "(" *)
          * (
                [ `Type_spec of type_spec | `Type_alias of type_alias ]
              * anon_choice_LF_249c99f
            )
              list (* zero or more *)
          * Token.t (* ")" *)
        )
    ]
)

type type_switch_statement (* inlined *) = (
    Token.t (* "switch" *)
  * type_switch_header
  * Token.t (* "{" *)
  * [ `Type_case of type_case | `Defa_case of default_case ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type unary_expression (* inlined *) = (
    [
        `PLUS of Token.t (* "+" *)
      | `DASH of Token.t (* "-" *)
      | `BANG of Token.t (* "!" *)
      | `HAT of Token.t (* "^" *)
      | `STAR of Token.t (* "*" *)
      | `AMP of Token.t (* "&" *)
      | `LTDASH of Token.t (* "<-" *)
    ]
  * expression
)

type var_declaration (* inlined *) = (
    Token.t (* "var" *)
  * [
        `Var_spec of var_spec
      | `LPAR_rep_var_spec_choice_LF_RPAR of (
            Token.t (* "(" *)
          * (var_spec * anon_choice_LF_249c99f) list (* zero or more *)
          * Token.t (* ")" *)
        )
    ]
)

type variadic_argument (* inlined *) = (expression * Token.t (* "..." *))

type variadic_parameter_declaration (* inlined *) = (
    identifier (*tok*) option
  * Token.t (* "..." *)
  * type_
)

type method_declaration (* inlined *) = (
    Token.t (* "func" *)
  * parameter_list
  * identifier (*tok*)
  * parameter_list
  * anon_choice_param_list_29faba4 option
  * block option
)

type function_declaration (* inlined *) = (
    Token.t (* "func" *)
  * identifier (*tok*)
  * type_parameter_list option
  * parameter_list
  * anon_choice_param_list_29faba4 option
  * block option
)

type import_declaration (* inlined *) = (
    Token.t (* "import" *)
  * [ `Import_spec of import_spec | `Import_spec_list of import_spec_list ]
)
